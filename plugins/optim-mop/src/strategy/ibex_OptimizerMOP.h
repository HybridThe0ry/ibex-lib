//============================================================================
//                                  I B E X
// File        : ibex_Optimizer.h
// Author      : Matias Campusano, Damir Aliquintui, Ignacio Araya
// Copyright   : IMT Atlantique (France)
// License     : See the LICENSE file
// Created     : Sep 24, 2017
// Last Update : Sep 24, 2017
//============================================================================

#ifndef __IBEX_OPTIMIZERMOP_H__
#define __IBEX_OPTIMIZERMOP_H__

#include "ibex_Ctc.h"
#include "ibex_Bsc.h"
#include "ibex_LoupFinderMOP.h"
#include "ibex_CellMOP.h"
#include "ibex_CtcKhunTucker.h"
#include "ibex_DistanceSortedCellBufferMOP.h"
#include "ibex_pyPlotter.h"

#include <set>
#include <map>
#include <list>
#include <stack>
#include <math.h>
//#include "ibex_DistanceSorted.h"

using namespace std;
namespace ibex {

/**
 * comparation function for sorting NDS by decreasing y
 */
struct sorty{
	bool operator()(const pair<double,double> p1, const pair<double,double> p2){
		return p1.second>p2.second;
	}
};

/**
 * Parameterized function f(t) ← f1(xt) - m*f2(xt)
 * xt = xa + t*(xb-xa)
 */
class PFunction{

public:
	PFunction(const Function& f1, const Function& f2, const Interval& m, const IntervalVector& xa, const IntervalVector& xb);

	Interval eval(const Interval& t) const;

	Interval deriv(const Interval& t) const;

private:

	const Function& f1;
	const Function& f2;
	Interval m;
	IntervalVector xa;
	IntervalVector xb;
};

class Node_t{
public:
	Node_t(Interval t, Interval ft) : t(t), ft(ft) { }

	friend bool operator>(Node_t& n1, Node_t& n2){
		return n1.ft.ub() > n2.ft.ub();
	}

	Interval t;
	Interval ft;
};


/**
 * \brief Global biObjetive Optimizer (ibexMOP).
 *
 * This class is an implementation of a global optimization algorithm for biObjective problems
 * described in https://github.com/INFPUCV/ibex-lib/tree/master/plugins/optim-mop by Araya et al.
 *
 * \remark In all the comments of this class, "NDS" means "Non Dominated Set"
 * related to the objectives f1 and f2
 */
class OptimizerMOP {

public:

	/**
	 * \brief Return status of the optimizer
	 *
	 * See comments for optimize(...) below.
	 */
	typedef enum {SUCCESS, INFEASIBLE, NO_FEASIBLE_FOUND, UNBOUNDED_OBJ, TIME_OUT, UNREACHED_PREC} Status;

	/**
	 *  \brief Create an optimizer.
	 *
	 * Inputs:
	 *   \param n        - number of variables of the <b>original system</b>
	 *   \param f1	     - the objective function f1
     *	 \param f2       - the objective function f2
	 *   \param ctc      - contractor for <b>extended<b> boxes (of size n+2)
	 *   \param bsc      - bisector for <b>extended<b> boxes (of size n+2)
	 *   \param buffer   - buffer for <b>extended<b> boxes (of size n+2)
	 *   \param finder   - the finder of ub solutions
	 *   \param eps	     - the required precision
	 *

	 *
	 * \warning The optimizer relies on the contractor \a ctc to contract the domain of the goal variable
	 *          and increase the uplo. If this contractor never contracts this goal variable,
	 *          the optimizer will only rely on the evaluation of f and will be very slow.
	 *
	 * We are assuming that the objective variables are n and n+1
	 *
	 */
	OptimizerMOP(int n, const Function &f1,  const Function &f2,
			Ctc& ctc, Bsc& bsc, CellBufferOptim& buffer, LoupFinderMOP& finder,  double eps=default_eps);

	/**
	 * \brief Delete *this.
	 */
	virtual ~OptimizerMOP();

	/**
	 * \brief Run the optimization.
	 *
	 * \param init_box             The initial box
	 *
	 * \return SUCCESS             if the global minimum (with respect to the precision required) has been found.
	 *                             In particular, at least one feasible point has been found, less than obj_init_bound, and in the
	 *                             time limit.
	 **
	 *         TIMEOUT             if time is out.
	 *
	 */
	Status optimize(const IntervalVector& init_box);

	/* =========================== Output ============================= */

	/**
	 * \brief Displays on standard output a report of the last call to optimize(...).
	 *
	 * Information provided:
	 * <ul><li> total running time
	 *     <li> totl number of cells (boxes)
	 *     <li> total number of best non-dominated solutions found
	 *     <li> the set of non-dominated solutions found
	 * </ul>
	 */
	void report(bool verbose=true);


	/**
	 * \brief Get the status.
	 *
	 * \return the status of last call to optimize(...).
	 */
	Status get_status() const;

	/**
	 * \brief Get the "UB" set of the pareto front.
	 *
	 * \return the UB of the last call to optimize(...).
	 */
	map< pair <double, double>, IntervalVector >& get_UB()  { return NDS; }

	//std::set< point2 >& get_LB()  { return LB; }

	/**
	 * \brief Get the time spent.
	 *
	 * \return the total CPU time of last call to optimize(...)
	 */
	double get_time() const;

	/**
	 * \brief Get the number of cells.
	 *
	 * \return the number of cells generated by the last call to optimize(...).
	 */
	double get_nb_cells() const;

	/**
	 * \brief returns the distance from the box to the current NDS
	 */
	static double distance2(const Cell* c);

	/* =========================== Settings ============================= */

	/**
	 * \brief Number of variables.
	 */
	const int n;

	/**
	 * \brief Objective functions
	 * Functions have the form: f1 - z1  and f2 - z2. Thus, in order to
	 * evaluate them we have to set z1 and z2 to [0,0].
	 */
	const Function& goal1;
	const Function& goal2;

	/**
	 * \brief Contractor for the extended system.
	 *
	 * The extended system:
	 * (y=f(x), g_1(x)<=0,...,g_m(x)<=0).
	 */
	Ctc& ctc;

	/**
	 * \brief Bisector.
	 *
	 * Must work on extended boxes.
	 */
	Bsc& bsc;

	/**
	 * Cell buffer.
	 */
	CellBuffer& buffer;

	/**
	 * \brief LoupFinder
	 */
	LoupFinderMOP& finder;

	/** Required precision for the envelope */
	double eps;


	/** Default precision: 0.01 */
	static const double default_eps;

	/**
	 * \brief Trace activation flag.
	 */
	int trace;

	/**
	 * \brief Time limit.
	 *
	 * Maximum CPU time used by the strategy.
	 * This parameter allows to bound time consumption.
	 * The value can be fixed by the user.
	 */
	double timeout;


	/* ======== Some other parameters of the solver =========== */

	//if true: Save a file to be plotted by plot.py (default value= false).
	bool static _plot;

	//Min distance between two non dominated points to be considered, expressed as a fraction of eps (default value= 0.1)
	double static _min_ub_dist;

	//True: the solver uses the upper envelope of the cy contract for contraction
	static bool _cy_upper;

	//True: the solver uses the lower envelope of the cy contract in contraction
	static bool cy_contract_var;

	//True: the solver reduces the search spaces by reducing the NDS vectors in (eps, eps)
	static bool _eps_contract;

	/**
	 * \brief Evaluate the goal in the point x
	 */
	static Interval eval_goal(const Function& goal, const IntervalVector& x, int n);

	/**
	 * \brief Gradient of the goal in the point x
	 */
	static IntervalVector deriv_goal(const Function& goal, const IntervalVector& x, int n);

protected:

	/**
	 * The contraction using y+cy
	 */
	void cy_contract(Cell& c);

	/**
	 * \brief Contract and bound procedure for processing a box.
	 *
	 * <ul>
	 * <li> contract the cell using #dominance_peeler() and #discard_generalized_monotonicty_test(),
	 * <li> contract with the contractor ctc,
	 * </ul>
	 *
	 */
	void contract_and_bound(Cell& c, const IntervalVector& init_box);

	/**
	 * \brief The box is reduced using the NDS
	 *
	 * Details are given in [Martin, B. et al.
	 * Constraint propagation using dominance in interval
	 * Branch & Bound for nonlinear biobjective optimization (2017)]
	 */
	void dominance_peeler(IntervalVector& box);

    /**
     *  \brief returns true if the facet orthogonal to the i direction of the box is feasible.
     *
     *  See #discard_generalized_monotonicty_test()
     */
    bool is_inner_facet(IntervalVector box, int i, Interval bound){
    	box.resize(n);
    	box[i]=bound;
    	return finder.norm_sys.is_inner(box);
    }

    /**
     * \brief return true is the pair is dominated by some NDS point, false otherwise
     */
    bool is_dominated(pair< double, double>& eval);

    /**
     * \brief Implements the method for discarding boxes proposed in [J. Fernandez and B. Toth,
     * "Obtaining the efficient set of nonlinear biobjective optimiza-tion  problems  via  interval
     * branch-and-bound  methods" (2009)]
     */
	void discard_generalized_monotonicty_test(IntervalVector& box, const IntervalVector& initbox);


	/**
	 * \brief Main procedure for updating the NDS.
	 * <ul>
	 * <li> finds two points in a polytope using the #LoupFinderMOP,
	 * <li> generate n equi-distant points between the two points,
	 * <li> correct the points using a Hansen feasibility test (See #PdcHansenFeasibility)
	 * <li> add the non-dominated vectors to NDS
	 * </ul>
	 */
	bool update_NDS(const IntervalVector& box);


	/**
	 * \brief Main procedure for updating the NDS.
	 * <ul>
	 * <li> finds two points xa and xb in a polytope using the #LoupFinderMOP,
	 * <li> finds a segment passing over the points (f1(x),f2(x)) in the segment xa-xb,
	 * <li> add the segment to NDS
	 * </ul>
	 */
	bool update_NDS2(const IntervalVector& box);


	/**
	 * \brief minimize/maximize the function pf: f1(t)+w*f2(t)
	 * returning the best solution found t and its the lb/ub of its evaluation
	 */
	pair<double, double> optimize_pf(PFunction& pf, bool minimize=false){
		if(minimize){
			cout << "minimize f1(t)+w*f2(t) is not implemented yet!" << endl;
			exit(0);
		}
		//deep-first search
		stack<Node_t> nodes;
		//std::priority_queue<Interval, std::vector<Interval> > nodes;

		double LB=NEG_INFINITY, eps=0.01;
		double UB=NEG_INFINITY;
		double best_t=0.0;

		Interval t=Interval(0.0,1.0);

		nodes.push(Node_t(t,pf.eval(t)));

		int i=0;
		while(!nodes.empty()){
			i++;
			Node_t n= nodes.top(); nodes.pop();

			//the nodes is removed if its ub is lower than LB+eps
			if(n.ft.ub() < LB+eps) {UB=std::max(UB, n.ft.ub()); continue;}

			//the size of the node is too small, then the UB is updated
			if(n.t.diam() < 0.01) {
				if(n.ft.ub() > UB) UB=n.ft.ub();
				continue;
			}

			//we search for a better solution in the midpoint
			double probing = pf.eval(n.t.mid()).ub();
			if(probing > LB) {
				best_t=n.t.mid();
				LB=probing;
			}


			//newton step
			Interval d(pf.deriv(n.t));

			while(true){
				Interval y0 = pf.eval(n.t.lb());
				if(y0.is_empty()) break;
				if(y0.ub() > LB) {LB=y0.ub(); best_t=n.t.lb(); break;}

				if(d.ub()==0.0) break;
				Interval x= (Interval(LB) - y0)/Interval(d.ub());

				//contract t
				if(x.lb()>eps)
					n.t=Interval((n.t.lb()+x).lb(),n.t.ub());
				else break;
			}

			while(true){
				Interval y0 = pf.eval(n.t.ub());
				if(y0.is_empty()) break;
				if(y0.ub() > LB) {LB=y0.ub(); best_t=n.t.ub(); break;}

				if(d.lb()==0.0) break;
				Interval x= (Interval(LB) - y0)/Interval(-d.lb());

				//contract t
				if(x.ub()>eps)
					n.t=Interval(n.t.lb(),(n.t.ub()-x).ub());
				else break;
			}

			//bisection
			Interval tl = Interval(n.t.lb(), n.t.mid());
			Interval tr = Interval(n.t.mid(), n.t.ub());

			nodes.push(Node_t(Interval(tl),pf.eval(tl)));
			nodes.push(Node_t(Interval(tr),pf.eval(tr)));
		}

		cout << i << endl;
		return make_pair(best_t, UB);

	}

	/**
	 * \brief Finds the lower segment dominated by (f1(x),f2(x)) for some point in the line xa-xb
	 */
	void dominated_segment(const IntervalVector& xa, const IntervalVector& xb){
		Interval ya1=OptimizerMOP::eval_goal(goal1,xa,n);
		Interval ya2=OptimizerMOP::eval_goal(goal2,xa,n);
		Interval yb1=OptimizerMOP::eval_goal(goal1,xb,n);
		Interval yb2=OptimizerMOP::eval_goal(goal2,xb,n);

		cout << "found two points" << endl;
		cout << "xa: " << xa << endl;
		cout << "xb: " << xb << endl;
		cout << "ya1: " << ya1 << endl;
		cout << "ya2: " << ya2 << endl;
		cout << "yb1: " << yb1 << endl;
		cout << "yb2: " << yb2 << endl;

		Interval m = (yb1-ya1)/(yb2-ya2);
		PFunction pf(goal1, goal2, m, xa, xb);

		cout << "m: " << m << endl;
		Interval derivate;
		//cout << "derivate (min, max): " << derivate << endl;

		double t1=0.0, t2=0.5, t3=1.0;
		double epsilon = 0.0003;
		cout << "c (t=" << t1 << "): " << pf.eval(t1) << endl;
		cout << "c (t=" << t2 << "): " << pf.eval(t2) << endl;
		cout << "c (t=" << t3 << "): " << pf.eval(t3) << endl;
		double lb = NEG_INFINITY;

		cout << "lb: " << lb << endl;


		stack<Interval> pila;
		pila.push(Interval(0,1));
		Interval inter, left, right;
		double point_t, point_c, t_before, error, min_interval;
		Interval y_r, y_c, y_l;
		double lb_interval;
		// global values
		error = 1e-5;
		min_interval = 1e-6;

		while(!pila.empty()) {
			inter = pila.top();
			pila.pop();
			cout << inter << endl;
			// lowerbounding
			y_r=pf.eval(inter.lb());
			y_c=pf.eval(inter.mid());
			y_l= pf.eval(inter.ub());

			lb_interval = max(max(y_r, y_c), y_l).ub();
			if(lb_interval > lb) lb = lb_interval;

			derivate = pf.deriv(inter);
			cout << "derivate (min, max): " << derivate << endl;

			// if derivate is empty the segment should not be created
			if(derivate.is_empty()) {
				cout << "derivate empty -> remove interval" << endl;
				// getchar();
				break;
			}
			// contract Newton from left
			point_t = inter.lb();
			point_c = pf.eval(point_t).ub();
			t_before = NEG_INFINITY;
			cout << "pendiente: " << derivate.ub() << endl;
			cout << "lb: " << lb << endl;
			cout << "point: (" << point_t << ", " << point_c << ")" << endl;
			cout << "while" << endl;
			cout << "point_t: " << point_t << endl;
			cout << "point_c: " << point_c << endl;
			cout << "lb: " << lb << endl;
			cout << "pendiente: " << derivate.ub() << endl;

			while(point_t - t_before > error and point_t < inter.ub()) {
				t_before = point_t;

				if(0 == derivate.ub())
					point_t = POS_INFINITY;
				else{
					// epsilon relativo: if |lb|<1: lb+eps, otherwise lb + |lb|*eps
					if(fabs(lb) < 1)
						point_t = (lb + epsilon - point_c)/derivate.ub() + t_before;
					else
						point_t = (lb + fabs(lb)*epsilon - point_c)/derivate.ub() + t_before;
					point_c = pf.eval(point_t).ub();
				}
				cout << "point_t: " << point_t << endl;
				cout << "point_c: " << point_c << endl;
				cout << "lb: " << lb << endl;
				cout << "pendiente: " << derivate.ub() << endl;
				// TODO: verificar si sucede este error en algun caso
				if(point_c > lb+epsilon) {
					cout << "ERRROR: point right is greater than lb" << endl;
				}
			}

			cout << inter << endl;
			cout << "point_t: " << point_t << endl;
			cout << "point_c: " << point_c << endl;

			// Se elimina el intervalo ya que no contiene una solucion mejor a lb+epsilon
			if(point_t >= inter.ub()) {
				//remover y salir
				cout << "remove and continue" << endl;
				// getchar();
				continue;
			} else {
				//se contracta el intervalo
				inter = Interval(point_t, inter.ub());
			}

			cout << inter << endl;

			// contract Newton from right
			point_t = inter.ub();
			point_c = pf.eval(point_t).ub();
			t_before = NEG_INFINITY;
			cout << "pendiente: " << derivate.lb() << endl;
			cout << "lb: " << lb << endl;
			cout << "point: (" << point_t << ", " << point_c << ")" << endl;
			cout << "while" << endl;
			cout << "point_t: " << point_t << endl;
			cout << "point_c: " << point_c << endl;
			cout << "lb: " << lb << endl;
			cout << "pendiente: " << derivate.lb() << endl;
			//TODO: verificar como afecta los resultados cuando la pendiente es 0 o infinita
			// si la pendiente cumple con los maximos y minimos permitidos

			while(t_before - point_t > error and point_t > inter.lb()) {
				t_before = point_t;

				if(0 == derivate.lb())
					point_t = NEG_INFINITY;
				else{
					// epsilon relativo: if |lb|<1: lb+eps, otherwise lb + |lb|*eps
					if(fabs(lb) < 1)
						point_t = t_before - (lb + epsilon - point_c)/derivate.lb();
					else
						point_t = t_before - (lb + fabs(lb)*epsilon - point_c)/derivate.lb();
					point_c = pf.eval(point_t).ub();
				}

				cout << "point_t: " << point_t << endl;
				cout << "point_c: " << point_c << endl;
				cout << "lb: " << lb << endl;
				cout << "pendiente: " << derivate.lb() << endl;
				// TODO: verificar si sucede este error en algun caso
				if(point_c > lb+epsilon) {
					cout << "ERRROR: point right is greater than lb" << endl;
				}
			}

			cout << inter << endl;
			cout << "point_t: " << point_t << endl;
			cout << "point_c: " << point_c << endl;
			// Se remueve
			if(point_t <= inter.lb()) {
				//TODO: remover y salir
				cout << "remove and break" << endl;
				// getchar();
				continue;
			} else {
				inter = Interval(inter.lb(), point_t);
			}
			cout << inter << endl;

			// bisect interval and push in stack
			if(inter.is_bisectable()) {
				pair<Interval,Interval> bsc = inter.bisect(0.5);
				pila.push(bsc.first);
				pila.push(bsc.second);
			}
			// getchar();
		}

		cout << "optim Newton:" << lb <<  endl;

		double step=1e-5;
		double tinf=0.0;
		double min = POS_INFINITY;
		double max = NEG_INFINITY;
		Interval maxinterval(0);
		while(tinf<1.0){
			double tsup=tinf+step;
			if(tsup>1.0) tsup=1.0;
			double ub = pf.eval(Interval(tinf,tsup)).ub();
			double lb = pf.eval(Interval(tinf,tsup)).lb();
			if(ub > max){maxinterval=Interval(tinf,tsup); max=ub;}
			if(lb < min) min=lb;
			tinf=tsup;

		}

		cout << "-----" << endl;
		//cout << "(" << ya1 << "," << ya2 << ")" << endl;
		//cout << "(" << yb1 << "," << yb2 << ")" << endl;
		//cout << m << endl;
		cout << pf.eval(Interval(0.0,1.0)) << endl;
		cout <<  "(" << min << "," << max << ")" << endl;
		cout << pf.eval(0.5) << endl;
		cout << pf.deriv(Interval(0.0,1.0)) << endl;

		pair <double,double> d = optimize_pf(pf, false);



		cout << "optim:" << d.second <<  endl;

		getchar();
	}


private:



	/**
	 * min feasible value found for each objective
	 */
    pair <double, double> y1_ub, y2_ub;

	/* Remember return status of the last optimization. */
	Status status;



	//TODO: this should not be static

	/** The current non-dominated set sorted by increasing x */
	static map< pair <double, double>, IntervalVector > NDS;

	/** The current non-dominated set sorted by decreasing y */
	map< pair <double, double>, IntervalVector, sorty > NDSy;


	/* CPU running time of the current optimization. */
	double time;

	/** Number of cells pushed into the heap (which passed through the contractors) */
	int nb_cells;

};

inline OptimizerMOP::Status OptimizerMOP::get_status() const { return status; }

inline double OptimizerMOP::get_time() const { return time; }

inline double OptimizerMOP::get_nb_cells() const { return nb_cells; }




} // end namespace ibex

#endif // __IBEX_OPTIMIZER_H__
