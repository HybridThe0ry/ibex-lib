//============================================================================
//                                  I B E X                                   
// File        : ibex_OptimProbing.cpp_
// Author      : Gilles Chabert, Ignacio Araya, Bertrand Neveu
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : May 14, 2012
// Last Update : May 14, 2012
//============================================================================

#include "ibex_Optimizer.h"
#include "ibex_BoolInterval.h"
#include "ibex_LineProbing.h"

#include <stdlib.h>
#include <math.h> // for fabs
#include <iomanip>

using namespace std;

namespace ibex {

void Optimizer::monotonicity_analysis(IntervalVector& box, bool inner_found) {

	if (!inner_found && sys.f_ctrs.nb_used_vars()==n)
		// if there is no inner box and all the variables appear
		// in the constraints, nothing can be done
		return;

	IntervalVector g(n);
	sys.goal->gradient(box,g);
	for (int j=0; j<n; j++) {
		//TODO: if box is unbounded, we have a problem here.
		if (inner_found || !sys.f_ctrs.used(j)) {
			if (g[j].lb()>=0 && box[j].lb()!=NEG_INFINITY) box[j]=box[j].lb();
			if (g[j].ub()<=0 && box[j].ub()!=POS_INFINITY) box[j]=box[j].ub();
		}
	}
}

bool Optimizer::is_feasible(const IntervalVector& box) {

	for (int j=0; j<m; j++) {
		if (entailed->normalized(j)) continue;
		Interval y=sys.ctrs[j].f.eval(box);
		if (y.lb()>0) return false;
	}
	return true;
}

bool Optimizer::is_inner(const IntervalVector& box) {
  //	cout << " box " << box << endl;
	for (int j=0; j<m; j++) {
		if (entailed->normalized(j)) continue;
		Interval ev=sys.ctrs[j].f.eval(box);
		if (ev.is_empty()) return false;
		if (ev.ub()>0) return false;

	}
	return true;
}


/* last update: IAR  */
bool Optimizer::in_HC4(IntervalVector& box) {
	if (!is_feasible(box)) { box.set_empty(); return false; }

	for (int j=0; j<m; j++) {
		if (entailed->normalized(j)) continue;
		sys.ctrs[j].f.ibwd(Interval(NEG_INFINITY,0),box);
		if (box.is_empty()) return false;
	}
	return true;
}

bool Optimizer::update_loup_probing(const IntervalVector& box) {

	IntervalVector inbox=box;
	bool inner_found=false;
	if (m==0)  // unconstrained problem
		inner_found=true;
	//	cout << "inbox " << inbox << endl;
	else {
		if (in_HC4_flag) {
			inner_found=in_HC4(inbox); // inbox will be contracted to an inner box (possibly empty)
			//		cout << "inner_found ? " << inner_found << " inbox=" << inbox << endl;
		}
		else {

			is_inside->contract(inbox); // compared to in_HC4, works the other way around: if inbox is inner, it is emptied.

			if (inbox.is_empty()) {
				inbox = box;
				inner_found=true;
			} else {
				inner_found=false;
				inbox.set_empty();
			}
		}
	}

	if (mono_analysis_flag)
		monotonicity_analysis(inbox, inner_found);

	bool loup_changed; // return value
	//	cout <<  " inner ? " << inner_found << " box " << box << " inbox " << inbox << endl;

	try {
		pair<Vector,double> p=LineProbing(sys).find(box,loup_point,pseudo_loup);
		loup_point = p.first;
		pseudo_loup = p.second;
		loup_changed=true;
	} catch(FeasiblePointFinder::NotFound&) {
		loup_changed=false;
	}

//	loup_changed = random_probing(inner_found? inbox : box, box, inner_found);

	if (loup_changed) {

		if (trace) trace_loup(inner_found);

		if (inner_found) {
			nb_inhc4++;
			diam_inhc4 = ((nb_inhc4-1) *diam_inhc4 + inbox.max_diam()) / nb_inhc4;
		} else {
			nb_rand++;
			diam_rand = ((nb_rand-1) *diam_rand + box.max_diam()) / nb_rand;
		}
	}

	return loup_changed;
}


void Optimizer::trace_loup (bool inner_found) {

	if (inner_found) cout << "[in!]";
	cout << setprecision (12) << " loup update " << pseudo_loup << " loup point  " << loup_point << endl;

}

} // end namespace
