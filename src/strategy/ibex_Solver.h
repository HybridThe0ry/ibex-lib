//============================================================================
//                                  I B E X                                   
// File        : ibex_Solver.h
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : May 13, 2012
// Last Update : Feb 02, 2017
//============================================================================

#ifndef __IBEX_SOLVER_H__
#define __IBEX_SOLVER_H__

#include "ibex_Ctc.h"
#include "ibex_Pdc.h"
#include "ibex_Bsc.h"
#include "ibex_CellBuffer.h"
#include "ibex_SubPaving.h"
#include "ibex_Timer.h"
#include "ibex_Exception.h"
#include "ibex_Solution.h"

#include <vector>

namespace ibex {

/**
 * \ingroup strategy
 *
 * \brief  Solver.
 *
 * This class implements an branch and prune algorithm that finds all the solutions of a systems of equations (the system may contain additional inequalities).
 *
 */

class CellLimitException : public Exception {} ;

class Solver {
public:
	/**
	 * \brief Return status of the solver
	 *
	 * See comments for solve(...) below.
	 */
	typedef enum {SUCCESS, INFEASIBLE, NOT_ALL_CERTIFIED, TIME_OUT, CELL_OVERFLOW} Status;

	/**
	 * \brief Build a solver.
	 *
	 * \param ctc    - The contractor (for contracting each node of the search tree)
	 * \param bsc    - The bisector   (for branching). Contains the stop criterion.
	 * \param buffer - The cell buffer (a CellStack in a depth first search strategy)
	 */
	Solver(Ctc& ctc, Bsc& bsc, CellBuffer& buffer);

	/**
	 * \brief Build a solver with certification.
	 *
	 * \param sys    - The system to be solved
	 * \param ctc    - The contractor (for contracting each node of the search tree)
	 * \param bsc    - The bisector   (for branching). Contains the stop criterion.
	 * \param buffer - The cell buffer (a CellStack in a depth first search strategy)
	 */
	Solver(const System& sys, Ctc& ctc, Bsc& bsc, CellBuffer& buffer);

	/**
	 * \brief Build a solver with certification.
	 *
	 * \param sys    - The system to be solved
	 * \param params - Force which dimensions correspond to parameters
	 * \param ctc    - The contractor (for contracting each node of the search tree)
	 * \param bsc    - The bisector   (for branching). Contains the stop criterion.
	 * \param buffer - The cell buffer (a CellStack in a depth first search strategy)
	 */
	Solver(const System& sys, const BitSet& params, Ctc& ctc, Bsc& bsc, CellBuffer& buffer);

	/**
	 * \brief Destructor.
	 */
	~Solver();

	/**
	 * \brief Solve the system (non-interactive mode).
	 *
	 * The vector of solutions (small boxes with the required precision) found by the solver
	 * are retrieved with #get_solutions().

	 * \param init_box - the initial box (the search space)
	 * \param sols - the output vector of solutions (will be populated by the solver)
	 * 
	 */
	Status solve(const IntervalVector& init_box);

	/**
	 * \brief Start solving (interactive mode).
	 *
	 * Can also be used to restart a new search.
	 */
	void start(const IntervalVector& init_box);

	/**
	 * \brief Find the next solution (interactive mode).
	 *
	 * \param sol - (output argument) pointer to the new solution (if found). This
	 *              is just the address of the last element in the "solutions" vector.
	 *              Set to NULL if search is over, time is out or the number of cells
	 *              exceeds the limit.
	 *
	 * \return true iff a new solution has been found.
	 */
	Status next(const Solution*& sol);

	/**
	 * \brief Displays on standard output a report of the last call to solve(...).
	 *
	 * Information provided:
	 * <ul><li> number of solutions
	 *     <li> solution #1
	 *     <li> ...
	 *     <li> solution #n
	 *     <li> total running time
	 *     <li> total number of cells (~boxes) created during the exploration
	 * </ul>
	 */
	void report(bool verbose=true, bool print_sols=false);

	/**
	 * \brief Get the status.
	 *
	 * \return the status of last call to solve(...).
	 */
	Status get_status() const;

	/**
	 * \brief Get the solutions
	 *
	 * \return the solutions of the last call to solve(...).
	 */
	const std::vector<Solution>& get_solutions() const;

	/**
	 * \brief Get the time spent.
	 *
	 * \return the total CPU time of last call to solve(...).
	 */
	double get_time() const;

	/**
	 * \brief Get the number of cells.
	 *
	 * \return the number of cells generated by the last call to solve(...).
	 */
	double get_nb_cells() const;

	/**
	 * Default bisection precision: 1e-6.
	 */
	static const double default_eps_x;

	/**
	 * \brief The contractor.
	 *
	 * Contractor used by the solver for contracting the current box at each node:
	 * generally, a sequence (with or without fixpoint) of different contractors (HC4,
	 * Acid, Newton, a linear relaxation, ... )
	 *
	 */ 
	Ctc& ctc;

	/**
	 * \brief The bisector.
	 *
	 * Tests also precision of boxes.
	 */
	Bsc& bsc;

	/**
	 * \brief Cell buffer.
	 */
	CellBuffer& buffer;

	/**
	 * \brief Maximum cpu time used by the solver.
	 *
	 * This parameter allows to bound time complexity.
	 * The value can be fixed by the user. By default, it is -1 (no limit).
	 */

	double time_limit;

	/**
	 * \brief Maximal number of cells created by the solver.
	 *
	 * This parameter allows to bound the number of nodes in the search tree.
	 * The value can be fixed by the user. By default, it is -1 (no limit).
	 */
	long cell_limit;

	/**
	 * \brief Trace level
	 *
	 *  Possible values:
	 *  0  - No trace  (default value)
	 *  1  - Each time a new solution is found, it is printed;
	 *  2  - At each node of the search, the current box is printed and
	 *       each time a new solution is found, it is printed.
	 */
	int trace;


protected:

	/**
	 * Whether certification is required or not.
	 */
	bool certification();

	/**
	 * Called by constructors.
	 */
	void init(const System& sys, const BitSet* params);

	/*
	 * Return true if the box "x" may contain a new solution, false otherwise.
	 *
	 * \param x   - (input) Candidate box
	 * \param sol - (output) Solution. Only built if return value is true.
	 *
	 * If it returns true and the status of "sol" is SOLUTION, the box "x" may have
	 * slightly changed (due to inflating Newton) and the actual solution
	 * is stored as the existence box of "sol".
	 */
	bool check_sol(IntervalVector& x, Solution& sol);

	/**
	 * Store the solution in "solutions" and print it (if trace>=0).
	 */
	void store_sol(const Solution& sol);

	/**
	 * Check if time is out.
	 */
	void time_limit_check();


	BitSet impact;

	/*
	 * Initial box of the current search.
	 */
	IntervalVector solve_init_box;

	/**
	 * Number of variables
	 */
	int n;

	/**
	 * Number of equalities. Only used if certification required (-1 otherwise)
	 */
	int m;

	/*
	 * The equalities to be solved. Only used if certification required.
	 */
	const System* eqs;

	/*
	 * The inequalities to be solved. Only used if certification required.
	 */
	const System* ineqs;

	/**
	 * The forced parameters (if any). Only used if certification required.
	 */
	const BitSet* params;

	/* Return status of the last solving. */
	Status status;

	/*
	 * \brief Solutions found in the current search.
	 */
	std::vector<Solution> solutions;

	/**
	 * \brief Number of certified solutions
	 */
	unsigned int nb_certified;

	/* CPU running time of the current solving. */
	double time;

	/** Number of cells of the current solving. */
	int nb_cells;
};

/*============================================ inline implementation ============================================ */

inline bool Solver::certification() {
	return m!=-1;
}

inline Solver::Status Solver::get_status() const { return status; }

inline const std::vector<Solution>& Solver::get_solutions() const { return solutions; }

inline double Solver::get_time() const { return time; }

inline double Solver::get_nb_cells() const { return nb_cells; }

} // end namespace ibex

#endif // __IBEX_SOLVER_H__
