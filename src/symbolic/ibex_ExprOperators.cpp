//============================================================================
//                                  I B E X
// File        : ibex_ExprOperators.cpp
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : Sep 28, 2018
// Last update : Oct 02, 2018
//============================================================================

#include "ibex_ExprOperators.h"
#include "ibex_SyntaxError.h"

// ##################################################################
//         This part should be generated by install scripts
#include "ibex_sinc.h"
#include "ibex_trace.h"
// ##################################################################

#include <sstream>

using namespace std;

namespace ibex {

namespace {
template<class Type>
Type& get(Domain& d);

template<>
Interval& get(Domain& d) { return d.i(); }

template<>
IntervalVector& get(Domain& d) { return d.v(); }

template<>
IntervalMatrix& get(Domain& d) { return d.m(); }

template<class Type>
const Type& get(const Domain& d);

template<>
const Interval& get(const Domain& d) { return d.i(); }

template<>
const IntervalVector& get(const Domain& d) { return d.v(); }

template<>
const IntervalMatrix& get(const Domain& d) { return d.m(); }

typedef struct {
	ExprGenericUnaryOp::dim_func dim;
	ExprGenericUnaryOp::eval_func eval;
	ExprGenericUnaryOp::bwd_func bwd;
	ExprGenericUnaryOp::num_diff_func num_diff;
	ExprGenericUnaryOp::symb_diff_func symb_diff;
} OperatorDef;

template<const char* Name, class Input, class Output>
class DomainUnaryOperator {
public:
	static Domain eval_domain(const Domain& x) {
		Domain y(UnaryOperator<Name,Input,Output>::dim(x.dim));
		get<Output>(y)=UnaryOperator<Name,Input,Output>::eval(get<Input>(x));
		return y;
	}
	static void bwd_domain(Domain& x, const Domain& y) {
		UnaryOperator<Name,Input,Output>::bwd(get<Input>(x),get<Output>(y));
	}

	static Domain num_diff_domain(const Domain& x, const Domain& g) {
		Domain y(x.dim);
		UnaryOperator<Name,Input,Output>::diff(get<Input>(x),get<Output>(g));
		return y;
	}
};

#define ADD_OPERATOR(NAME,INPUT,OUTPUT) \
if (strcmp(op_name,NAME)==0) { \
	def.dim       = &UnaryOperator<NAME,INPUT,OUTPUT>::dim; \
	def.eval      = &DomainUnaryOperator<NAME,INPUT,OUTPUT>::eval_domain; \
	def.bwd       = &DomainUnaryOperator<NAME,INPUT,OUTPUT>::bwd_domain; \
	def.num_diff  = &DomainUnaryOperator<NAME,INPUT,OUTPUT>::num_diff_domain; \
	def.symb_diff = &UnaryOperator<NAME,INPUT,OUTPUT>::diff; \
	return def; \
}

OperatorDef get(const char* op_name) {

	OperatorDef def;

	// ##################################################################
	//         This part should be generated by install scripts
	// ##################################################################
	ADD_OPERATOR(SINC,Interval,Interval);
	ADD_OPERATOR(TRACE,IntervalMatrix,IntervalVector);
	// ##################################################################

	stringstream ss;
	ss << "unkown operator \"" << op_name << "\"";
	throw SyntaxError(ss.str());
}

}

const ExprGenericUnaryOp& ExprGenericUnaryOp::new_(const char* op_name, const ExprNode& expr) {
	return *new ExprGenericUnaryOp(op_name, expr);
}


ExprGenericUnaryOp::ExprGenericUnaryOp(const char* op_name, const ExprNode& subexpr) :
		ExprUnaryOp(subexpr, get(op_name).dim(subexpr.dim)), name(strdup(name)) {

	OperatorDef def=get(op_name);
	eval = def.eval;
	bwd = def.bwd;
	num_diff = def.num_diff;
	symb_diff = def.symb_diff;
}

ExprGenericUnaryOp::eval_func ExprGenericUnaryOp::get_eval(const char* name) {
	return get(name).eval;
}

ExprGenericUnaryOp::~ExprGenericUnaryOp() {
	free((char*) name);
}

} // end namespace
